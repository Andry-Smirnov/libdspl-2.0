
/*! ****************************************************************************
\ingroup SPEC_MATH_COMMON_GROUP
\fn int concat(void* a, size_t na, void* b, size_t nb, void* c) 
\brief Конкатенация двух массивов данных

Функция производит конкатенацию двух массивов. Пусть массивы `a` и `b` 
заданы как векторы:<BR>
`a = [a(0), a(1), ... a(na-1)]`, <BR>
`b = [b(0), b(1), ... b(nb-1)]`, <BR>
тогда результатом конкатенации будет вектор размера `na+nb` вида:<BR>
`c = [a(0), a(1), ... a(na-1), b(0), b(1), ... b(nb-1)]`.


\param[in]  a   Указатель на первый вектор `a`.<BR>
                Размер вектора `na` байт.<BR><BR>

\param[in]  na  Размер первого вектора `a` в байт.<BR><BR>

\param[in]  b   Указатель на второй вектор `b`.<BR>
                Размер памяти вектора `nb` байт.<BR><BR>

\param[in]  nb  Размер второго вектора `b` в байт.<BR><BR>

\param[out] c   Указатель на вектор конкатенации `c`.<BR>
                Размер памяти вектора `na + nb` байт.<BR>
                Память должна быть выделена.<BR><BR>

\return
`RES_OK` если функция выполнена успешно.<BR>
 В противном случае \ref ERROR_CODE_GROUP "код ошибки".
 
Функция использует указатели типа `void*` и может быть использована для 
конкатенации данных различного типа.<BR>
Например конкатенация массивов типа `double`:
\code{.cpp}
double a[3] = {1.0, 2.0, 3.0};
double b[2] = {4.0, 5.0};
double c[5];

concat((void*)a, 3*sizeof(double), (void*)b, 2*sizeof(double), (void*)c);
\endcode 
в результате вектор `c` будет хранить массив данных:
\verbatim
c = [1.0, 2.0, 3.0, 4.0, 5.0]
\endverbatim

\author Бахурин Сергей, www.dsplib.org
**************************************************************************** */





/*! ****************************************************************************
\ingroup SPEC_MATH_COMMON_GROUP
\fn int decimate(double* x, int n, int d, double* y, int* cnt) 
\brief Децимация вещественного вектора данных

Функция производит децимацию вещественного вектора `x` в `d` раз.<BR>
В результате выходной вектор `y` содержит значения:
`y(k) = x(k*d), k = 0...n/d-1`<BR>

\param[in]  x   Указатель на вектор входных данных `x`.<BR>
                Размер вектора `[n x 1]`.<BR><BR>

\param[in]  n   Размер входного вектора `x`.<BR><BR>

\param[in]  d   Коэффициент децимации.<BR>
                В результате децимации из вектора `x` будет взять каждый
                d-й элемент.<BR><BR>

\param[out] y   Указатель на децимированный вектор `y`.<BR>
                Размер выходного вектора равен `[n/d x 1]` 
                будет сохранен по адресу `cnt`.<BR>
                Память должна быть выделена.<BR><BR>

\param[out] cnt Указатель переменную, в которую будет сохранен
                размер выходного вектора после децимации.<BR>
                Указатель может быть `NULL`, в этом случае 
                размер вектора `y` не возвращается.<BR><BR>

\return
`RES_OK` если функция выполнена успешно.<BR>
 В противном случае \ref ERROR_CODE_GROUP "код ошибки".

Пример децимации вещественного массива данных в 2 раза:
\code{.cpp}
double x[10] = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0};
double y[5];
int d = 2;
int cnt;

decimate(x, 10, d, y, &cnt);
\endcode 
в результате в переменную `cnt` будет записан размер 5, 
а вектор `y` будет хранить массив данных:
\verbatim
c = [0.0, 2.0, 4.0, 6.0, 8.0]
\endverbatim

\author Бахурин Сергей www.dsplib.org
**************************************************************************** */



/*! ****************************************************************************
\ingroup SPEC_MATH_COMMON_GROUP
\fn int decimate_cmplx(complex_t* x, int n, int d, complex_t* y, int* cnt)
\brief Децимация комплексного вектора данных

Функция производит децимацию комплексного вектора `x` в `d` раз.<BR>
В результате выходной вектор `y` содержит значения:
`y(k) = x(k*d), k = 0...n/d-1`<BR>

\param[in]  x   Указатель на вектор входных данных `x`.<BR>
                Размер вектора `[n x 1]`.<BR><BR>

\param[in]  n   Размер входного вектора `x`.<BR><BR>

\param[in]  d   Коэффициент децимации.<BR>
                В результате децимации из вектора `x` будет взять каждый
                d-й элемент.<BR><BR>

\param[out] y   Указатель на децимированный вектор `y`.<BR>
                Размер выходного вектора равен `[n/d x 1]` 
                будет сохранен по адресу `cnt`.<BR>
                Память должна быть выделена.<BR><BR>

\param[out] cnt Указатель переменную, в которую будет сохранен
                размер выходного вектора после децимации.<BR>
                Указатель может быть `NULL`, в этом случае 
                размер вектора `y` не возвращается.<BR><BR>

\return
`RES_OK` если функция выполнена успешно.<BR>
 В противном случае \ref ERROR_CODE_GROUP "код ошибки".

Пример децимации комплексного массива данных в 2 раза:
\code{.cpp}
compex_t x[10] = {{0.0, 0.0}, {1.0, 1.0}, {2.0, 2.0}, {3.0, 3.0}, {4.0, 4.0},
                  {5.0, 5.0}, {6.0, 6.0}, {7.0, 7.0}, {8.0, 8.0}, {9.0, 9.0}};
compex_t y[5];
int d = 2;
int cnt;

decimate_cmplx(x, 10, d, y, &cnt);
\endcode 
в результате в переменную `cnt` будет записан размер 5, 
а вектор `y` будет хранить массив данных:
\verbatim
c = [0.0+0.0j, 2.0+2.0j, 4.0+4.0j, 6.0+6.0j, 8.0+8.0j]
\endverbatim

\author Бахурин Сергей www.dsplib.org
**************************************************************************** */



/*! ****************************************************************************
\ingroup SPEC_MATH_STAT_GROUP
\fn int find_max_abs(double* a, int n, double* m, int* ind)
\brief Поиск максимального по модулю элемента вещественного вектора `a`

Функция производит поиск максимального по модулю значения вектора `a`.<BR>
Максимальное по модулю значение `max|a[k]|` сохраняется по адресу `m`, а индекс
данного значения в векторе `a` сохраняется по адресу `ind`.<BR>

\param[in]  a   Указатель на вещественный вектор `a`.<BR>
                Размер вектора `[n x 1]`.<BR><BR>

\param[in]  n   Размер входного вектора `a`.<BR><BR>


\param[out] m   Указатель на адрес памяти, в который сохранить
                максимальное по модулю значение вектора `a`.<BR>
                Указатель может быть `NULL`, в этом случае 
                максимальное по модулю значение не сохраняется.<BR><BR>

\param[out] ind Указатель на переменную, в которую будет сохранен
                индекс максимального по модулю значению вектора `a`.<BR>
                Указатель может быть `NULL`, в этом случае 
                индекс не возвращается.<BR><BR>

\return
`RES_OK` если функция выполнена успешно.<BR>
 В противном случае \ref ERROR_CODE_GROUP "код ошибки".

Пример:
\code{.cpp}
  double a[5] = {0.0, 2.0, -5.0, 4.0, 2.0};
  double m;
  int ind;
  find_max_abs(a, 5, &m, &ind);
  printf("\n\nmax absolute value:    %8.1f  (index %d)", m, ind);
\endcode 
в результате в переменную `m` будет записано значение `5`, 
а в переменную `ind` значение `2`.

\author Бахурин Сергей www.dsplib.org
**************************************************************************** */


/*! ****************************************************************************
\ingroup SPEC_MATH_COMMON_GROUP
\fn int flipip(double* x, int n)
\brief Функция отражения вещественного вектора `x`

Функция производит отражение вещественного вектора длины `n` 
в памяти данных.<BR>
Например исходный вектор `x`  длины 6:<BR>
\verbatim
x = [0, 1, 2, 3, 4, 5]
\endverbatim
После отражения вектор `x` будет иметь вид:
\verbatim
x = [5, 4, 3, 2, 1, 0]
\endverbatim

\param[in, out] x   Указатель на вещественный вектор `x`.<BR>
                    Размер вектора `[n x 1]`.<BR>
                    Результат отражения будет помещен по этому же адресу.<BR>

\param[in]      n   Размер вектора `x`.<BR><BR>

\return
`RES_OK` если функция выполнена успешно.<BR>
 В противном случае \ref ERROR_CODE_GROUP "код ошибки".

Пример:
\code{.cpp}
double x[5] = {0.0, 1.0, 2.0, 3.0, 4.0};
int i;  
for(i = 0; i < 5; i++)
  printf("%6.1f  ", x[i]);
flipip(x, 5);
printf("\n");
for(i = 0; i < 5; i++)
  printf("%6.1f  ", x[i]);
\endcode 
<BR>
Результат выполнения:
\verbatim
   0.0     1.0     2.0     3.0     4.0
   4.0     3.0     2.0     1.0     0.0
\endverbatim

\author Бахурин Сергей www.dsplib.org
**************************************************************************** */



/*! ****************************************************************************
\ingroup SPEC_MATH_COMMON_GROUP
\fn int flipip_cmplx(complex_t* x, int n)
\brief Функция отражения комплексного вектора `x`

Функция производит отражение комплексного вектора длины `n` 
в памяти данных.<BR>
Например исходный вектор `x`  длины 6:<BR>
\verbatim
x = [0+0j, 1+1j, 2+2j, 3+3j, 4+4j, 5+5j]
\endverbatim
После отражения вектор `x` будет иметь вид:
\verbatim
x = [5+5j, 4+4j, 3+3j, 2+2j, 1+1j, 0+0j]
\endverbatim

\param[in, out] x   Указатель на комплексный вектор `x`.<BR>
                    Размер вектора `[n x 1]`.<BR>
                    Результат отражения будет помещен по этому же адресу.<BR>

\param[in]      n   Размер вектора `x`.<BR><BR>

\return
`RES_OK` если функция выполнена успешно.<BR>
 В противном случае \ref ERROR_CODE_GROUP "код ошибки".

Пример:
\code{.cpp}
complex_t y[5] = {{0.0, 0.0}, {1.0, 1.0}, {2.0, 2.0}, {3.0, 3.0}, {4.0, 4.0}};
for(i = 0; i < 5; i++)
  printf("%6.1f%+.1fj  ", RE(y[i]), IM(y[i]));
flipip_cmplx(y, 5);
printf("\n");
for(i = 0; i < 5; i++)
  printf("%6.1f%+.1fj  ", RE(y[i]), IM(y[i]));
\endcode 
<BR>
Результат выполнения:
\verbatim
   0.0+0.0j     1.0+1.0j     2.0+2.0j     3.0+3.0j     4.0+4.0j
   4.0+4.0j     3.0+3.0j     2.0+2.0j     1.0+1.0j     0.0+0.0j
\endverbatim

\author Бахурин Сергей www.dsplib.org
**************************************************************************** */



/*! ****************************************************************************
\ingroup SPEC_MATH_COMMON_GROUP
\fn int verif(double* x,  double* y, size_t n, double eps, double* err)
\brief Верификация вещественных массивов

Функция производит расчет максимальной относительной ошибки между вещественными 
векторами `x` и `y` равной длины `n`:

\f[
e = \max \left( \frac{|x(k) - y(k)| }{ |x(k)|} \right), \quad  \quad |x(k)| > 0,
\f]
или 
\f[
e = \max(|x(k) - y(k)| ), ~\qquad  \quad~|x(k)| = 0,
\f]
 и возвращает `DSPL_VERIF_SUCCESS` если 
разница \f$ e\f$ меньше `eps`. 
В противном случае возвращает `DSPL_VERIF_FAILED`.<BR>
Данная функция используется для верификации работы алгоритмов если вектор `x` 
результат работы алгоритма пользователя, а `y` -- результат работы этого же 
алгоритма сторонней функцией.

\param[in] x        Указатель на первый вектор `x`.<BR>
                    Размер вектора `[n x 1]`.<BR><BR>

\param[in] y        Указатель на второй вектор `y`.<BR>
                    Размер вектора `[n x 1]`.<BR><BR>

\param[in] n        Размер векторов `x` и `y`.<BR><BR>

\param[in] eps      Допустимая относительная ошибка.<BR>
                    Если максимальная относительная ошибка меньше `eps`, то 
                    функция возвращает `DSPL_VERIF_SUCCESS`, в противном случае
                    `DSPL_VERIF_FAILED`. <BR><BR>

\param[in, out] err Указатель на переменную максимальной 
                    относительной ошибки.<BR>
                    По данному адресу будет записано значение максимальной
                    относительной ошибки.<BR>
                    Указатель может быть `NULL`, значение ошибки в этом
                    случае не возвращается.<BR><BR>

\return
`DSPL_VERIF_SUCCESS` если относительная ошибка меньше `eps`.<BR>
 В противном случае `DSPL_VERIF_FAILED`.

\author Бахурин Сергей www.dsplib.org
**************************************************************************** */





/*! ****************************************************************************
\ingroup SPEC_MATH_COMMON_GROUP
\fn int verif_cmplx(complex_t* x,  complex_t* y, size_t n, 
                         double eps, double* err)
\brief Верификация комплексных массивов

Функция производит расчет максимальной относительной ошибки между комплексными 
векторами `x` и `y` равной длины `n`:

\f[
e = \max \left( \frac{|x(k) - y(k)| }{ |x(k)|} \right), \quad  \quad |x(k)| > 0,
\f]
или 
\f[
e = \max(|x(k) - y(k)| ), ~\qquad  \quad~|x(k)| = 0,
\f]
 и возвращает `DSPL_VERIF_SUCCESS` если 
разница \f$ e\f$ меньше `eps`. 
В противном случае возвращает `DSPL_VERIF_FAILED`.<BR>
Данная функция используется для верификации работы алгоритмов если вектор `x` 
результат работы алгоритма пользователя, а `y` -- результат работы этого же 
алгоритма сторонней функцией.

\param[in] x        Указатель на первый вектор `x`.<BR>
                    Размер вектора `[n x 1]`.<BR><BR>

\param[in] y        Указатель на второй вектор `y`.<BR>
                    Размер вектора `[n x 1]`.<BR><BR>

\param[in] n        Размер векторов `x` и `y`.<BR><BR>

\param[in] eps      Допустимая относительная ошибка.<BR>
                    Если максимальная относительная ошибка меньше `eps`, то 
                    функция возвращает `DSPL_VERIF_SUCCESS`, в противном случае
                    `DSPL_VERIF_FAILED`. <BR><BR>

\param[in, out] err Указатель на переменную максимальной 
                    относительной ошибки.<BR>
                    По данному адресу будет записано значение максимальной
                    относительной ошибки.<BR>
                    Указатель может быть `NULL`, значение ошибки в этом
                    случае не возвращается.<BR><BR>

\return
`DSPL_VERIF_SUCCESS` если функция выполнена успешно.<BR>
 В противном случае `DSPL_VERIF_FAILED`.

\author Бахурин Сергей www.dsplib.org
**************************************************************************** */

