
/*! ****************************************************************************
\ingroup FILTER_CONV_GROUP
\fn int conv(double* a, int na, double* b, int nb, double* c) 
\brief Линейная свертка двух вещественных векторов

Функция рассчитывает линейную свертку двух векторов \f$ c = a * b\f$.

\param[in]  a   Указатель на первый вектор  \f$a\f$.<BR>
                Размер вектора `[na x 1]`.<BR><BR>

\param[in]  na  Размер первого вектора.<BR><BR>

\param[in]  b   Указатель на второй вектор \f$b\f$.<BR>
                Размер вектора `[nb x 1]`.<BR><BR>

\param[in]  nb  Размер второго вектора.<BR><BR>

\param[out] c   Указатель на вектор свертки \f$ c = a * b\f$.<BR>
                Размер вектора `[na + nb - 1  x  1]`.<BR>
                Память должна быть выделена.<BR><BR>

\return
`RES_OK` если свертка расчитана успешно.<BR>
 В противном случае \ref ERROR_CODE_GROUP "код ошибки".

\note Если вектора `a` и `b` представляют собой коэффициенты двух полиномов,
то результат линейной свертки представляет собой коэффициенты произведения
исходных полиномов.

Пример использования функции:

\code{.cpp}
  double ar[3] = {1.0, 2.0, 3.0};
  double br[4] = {3.0, -1.0, 2.0, 4.0};
  double cr[6];
  
  int n;
  
  conv(ar, 3, br, 4, cr);
  
  for(n = 0; n < 6; n++)
    printf("cr[%d] = %5.1f\n", n, cr[n]);

\endcode
<BR>

Результат работы:
\verbatim
cr[0] =   3.0
cr[1] =   5.0
cr[2] =   9.0
cr[3] =   5.0
cr[4] =  14.0
cr[5] =  12.0
\endverbatim

\author Бахурин Сергей www.dsplib.org
**************************************************************************** */







/*! ****************************************************************************
\ingroup FILTER_CONV_GROUP
\fn int conv_cmplx(complex_t* a, int na, complex_t* b, int nb, complex_t* c) 
\brief Линейная свертка двух комплексных векторов

Функция рассчитывает линейную свертку двух векторов \f$ c = a * b\f$.



\param[in]  a     Указатель на первый вектор  \f$a\f$.<BR>
                  Размер вектора `[na x 1]`.<BR><BR>

\param[in]  na    Размер первого вектора.<BR><BR>

\param[in]  b     Указатель на второй вектор \f$b\f$.<BR>
                  Размер вектора `[nb x 1]`.<BR><BR>

\param[in]  nb    Размер второго вектора.<BR><BR>

\param[out] c     Указатель на вектор свертки \f$ c = a * b\f$.<BR>
                  Размер вектора `[na + nb - 1  x  1]`.<BR>
                  Память должна быть выделена.<BR><BR>

\return
`RES_OK`          если свертка рассчитана успешно.<BR>
 В противном случае \ref ERROR_CODE_GROUP "код ошибки".


\note Если вектора `a` и `b` представляют собой коэффициенты двух полиномов,
то результат линейной свертки представляет собой коэффициенты произведения
исходных полиномов.

Пример использования функции:

\code{.cpp}
  complex_t ac[3] = {{0.0, 1.0}, {1.0, 1.0}, {2.0, 2.0}};
  complex_t bc[4] = {{3.0, 3.0}, {4.0, 4.0}, {5.0, 5.0}, {6.0, 6.0}};
  complex_t cc[6];
  
  int n;
  
  conv_cmplx(ac, 3, bc, 4, cc);
  
  for(n = 0; n < 6; n++)
    printf("cc[%d] = %5.1f%+5.1fj\n", n, RE(cc[n]),IM(cc[n]));
  
\endcode
<BR>

Результат работы:
\verbatim
cc[0] =  -3.0 +3.0j
cc[1] =  -4.0+10.0j
cc[2] =  -5.0+25.0j
cc[3] =  -6.0+32.0j
cc[4] =   0.0+32.0j
cc[5] =   0.0+24.0j
\endverbatim

\author Бахурин Сергей www.dsplib.org
***************************************************************************** */









/*! ****************************************************************************
\ingroup FILTER_CONV_GROUP
\fn int conv_fft_cmplx(complex_t* a, int na, complex_t* b, int nb,
                       fft_t* pfft, complex_t* c) 
\brief Линейная свертка двух комплексных векторов с использованием алгоритмов
быстрого преобразования Фурье

Функция рассчитывает линейную свертку двух векторов \f$ c = a * b\f$ используя
секционную обработку с перекрытием в частотной области. Это позволяет сократить 
вычислительные операции при расчете длинных сверток.



\param[in]  a     Указатель на первый вектор  \f$a\f$.<BR>
                  Размер вектора `[na x 1]`.<BR><BR>

\param[in]  na    Размер первого вектора.<BR><BR>

\param[in]  b     Указатель на второй вектор \f$b\f$.<BR>
                  Размер вектора `[nb x 1]`.<BR><BR>
                  
\param[in]  nb    Размер второго вектора.<BR><BR>

\param[in]  pfft  Указатель на структуру `fft_t` алгоритма 
                  быстрого преобразования Фурье.<BR>
                  Функция изменит состояние полей структуры `fft_t`,
                  поэтому структура должна быть очищена перед выходом из 
                  программы для исключения утечек памяти.<BR>

\param[out] c     Указатель на вектор свертки \f$ c = a * b\f$.<BR>
                  Размер вектора `[na + nb - 1  x  1]`.<BR>
                  Память должна быть выделена.<BR><BR>

\return
`RES_OK`          если свертка рассчитана успешно.<BR>
 В противном случае \ref ERROR_CODE_GROUP "код ошибки".


\note Данная функция наиболее эффективна при вычислении длинных сверток.

Пример использования функции:

\include conv_fft_cmplx_test.c

Результат работы:
\verbatim
c[  0] =     -1.00    -0.00j    d[  0] =     -1.00    +0.00j
c[  1] =     -6.00    +4.00j    d[  1] =     -6.00    +4.00j
c[  2] =    -15.00   +20.00j    d[  2] =    -15.00   +20.00j
c[  3] =    -28.00   +56.00j    d[  3] =    -28.00   +56.00j
c[  4] =    -45.00  +120.00j    d[  4] =    -45.00  +120.00j
c[  5] =    -55.00  +210.00j    d[  5] =    -55.00  +210.00j
c[  6] =    -65.00  +300.00j    d[  6] =    -65.00  +300.00j
c[  7] =    -75.00  +390.00j    d[  7] =    -75.00  +390.00j
c[  8] =    -85.00  +480.00j    d[  8] =    -85.00  +480.00j
c[  9] =    -95.00  +570.00j    d[  9] =    -95.00  +570.00j
c[ 10] =   -105.00  +660.00j    d[ 10] =   -105.00  +660.00j
c[ 11] =   -115.00  +750.00j    d[ 11] =   -115.00  +750.00j
c[ 12] =   -125.00  +840.00j    d[ 12] =   -125.00  +840.00j
c[ 13] =   -135.00  +930.00j    d[ 13] =   -135.00  +930.00j
c[ 14] =   -145.00 +1020.00j    d[ 14] =   -145.00 +1020.00j
c[ 15] =   -124.00 +1080.00j    d[ 15] =   -124.00 +1080.00j
c[ 16] =    -99.00 +1016.00j    d[ 16] =    -99.00 +1016.00j
c[ 17] =    -70.00  +820.00j    d[ 17] =    -70.00  +820.00j
c[ 18] =    -37.00  +484.00j    d[ 18] =    -37.00  +484.00j
\endverbatim

\author Бахурин Сергей www.dsplib.org
***************************************************************************** */






/*! ****************************************************************************
\ingroup FILTER_CONV_GROUP
\fn int filter_iir(double* b, double* a, int ord, double* x, int n, double* y)
\brief Фильтрация вещественного сигнала вещественным БИХ-фильтром

Функция рассчитывает выход фильтра заданного выражением
\f[
  H(z) = \frac{\sum_{n = 0}^{N} b_n  z^{-n}}
  {1+{\frac{1}{a_0}}\sum_{m = 1}^{M} a_m  z^{-n}},
\f]
где \f$a_0\f$ не может быть 0, \f$N=M=\f$`ord`.


\param[in]  b     Указатель на вектор коэффициентов числителя 
                  передаточной функции БИХ-фильтра.<BR> 
                  Размер вектора `[ord + 1 x 1]`.<BR><BR> 

\param[in]  a     Указатель на вектор коэффициентов знаменателя
                  передаточной функции БИХ-фильтра.<BR> 
                  Размер вектора `[ord + 1 x 1]`.<BR> 
                  Этот указатель может быть `NULL`, 
                  тогда фильтрация производится без использования 
                  рекурсивной части.<BR><BR> 

\param[in]  ord   Порядок фильтра. Количество коэффициентов числителя 
                  и знаменателя передаточной функции 
                  БИХ-фильтра равно `ord + 1`.<BR><BR> 

\param[in]  x     Указатель на вектор отсчетов входного сигнала.<BR> 	
                  Размер вектора `[n x 1]`.<BR><BR> 

\param[in]  n     Длина входного сигнала.<BR><BR> 

\param[out] y     Указатель на вектор выходных отсчетов фильтра.<BR> 
                  Размер вектора `[n x  1]`.<BR> 
                  Память должна быть выделена заранее.<BR><BR> 
\return
`RES_OK` Если фильтрация произведена успешно.<BR>
В противном случае \ref ERROR_CODE_GROUP "код ошибки":<BR>

\author
Бахурин Сергей 
www.dsplib.org
***************************************************************************** */






