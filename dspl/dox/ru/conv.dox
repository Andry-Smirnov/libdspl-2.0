
/*! ****************************************************************************
\ingroup FILTER_CONV_GROUP
\fn int conv(double* a, int na, double* b, int nb, double* c) 
\brief Линейная свертка двух вещественных векторов

Функция рассчитывает линейную свертку двух векторов \f$ c = a * b\f$.

\param[in]  a
Указатель на первый вектор  \f$a\f$.  \n
Размер вектора `[na x 1]`.  \n \n 

\param[in]  na
Размер первого вектора. \n \n

\param[in]  b
Указатель на второй вектор \f$b\f$.  \n
Размер вектора `[nb x 1]`. \n  \n

\param[in]  nb
Размер второго вектора. \n \n

\param[out] c
Указатель на вектор свертки \f$ c = a * b\f$. \n
Размер вектора `[na + nb - 1  x  1]`. \n
Память должна быть выделена. \n \n

\return
`RES_OK` если свертка расчитана успешно. \n 
 В противном случае \ref ERROR_CODE_GROUP "код ошибки".

\note
Если вектора `a` и `b` представляют собой коэффициенты двух полиномов,
то результат линейной свертки представляет собой коэффициенты произведения
исходных полиномов.

Пример использования функции:

\code{.cpp}
  double ar[3] = {1.0, 2.0, 3.0};
  double br[4] = {3.0, -1.0, 2.0, 4.0};
  double cr[6];
  
  int n;
  
  conv(ar, 3, br, 4, cr);
  
  for(n = 0; n < 6; n++)
    printf("cr[%d] = %5.1f \n ", n, cr[n]);

\endcode
\n 

Результат работы:
\verbatim
cr[0] =   3.0
cr[1] =   5.0
cr[2] =   9.0
cr[3] =   5.0
cr[4] =  14.0
cr[5] =  12.0
\endverbatim

\author
Бахурин Сергей
www.dsplib.org
**************************************************************************** */







/*! ****************************************************************************
\ingroup FILTER_CONV_GROUP
\fn int conv_cmplx(complex_t* a, int na, complex_t* b, int nb, complex_t* c) 
\brief Линейная свертка двух комплексных векторов

Функция рассчитывает линейную свертку двух векторов \f$ c = a * b\f$.



\param[in]  a
Указатель на первый вектор  \f$a\f$. \n 
Размер вектора `[na x 1]`. \n  \n 

\param[in]  na
Размер первого вектора. \n  \n 

\param[in]  b
Указатель на второй вектор \f$b\f$. \n 
Размер вектора `[nb x 1]`. \n  \n 

\param[in]  nb
Размер второго вектора. \n  \n 

\param[out] c
Указатель на вектор свертки \f$ c = a * b\f$. \n 
Размер вектора `[na + nb - 1  x  1]`. \n 
Память должна быть выделена. \n  \n 

\return
`RES_OK` если свертка рассчитана успешно. \n 
В противном случае \ref ERROR_CODE_GROUP "код ошибки".


\note 
Если векторы `a` и `b` представляют собой коэффициенты двух полиномов,
то результат линейной свертки представляет собой коэффициенты произведения
исходных полиномов.

Пример использования функции:

\code{.cpp}
  complex_t ac[3] = {{0.0, 1.0}, {1.0, 1.0}, {2.0, 2.0}};
  complex_t bc[4] = {{3.0, 3.0}, {4.0, 4.0}, {5.0, 5.0}, {6.0, 6.0}};
  complex_t cc[6];
  
  int n;
  
  conv_cmplx(ac, 3, bc, 4, cc);
  
  for(n = 0; n < 6; n++)
    printf("cc[%d] = %5.1f%+5.1fj \n ", n, RE(cc[n]),IM(cc[n]));
  
\endcode
\n 

Результат работы:
\verbatim
cc[0] =  -3.0 +3.0j
cc[1] =  -4.0+10.0j
cc[2] =  -5.0+25.0j
cc[3] =  -6.0+32.0j
cc[4] =   0.0+32.0j
cc[5] =   0.0+24.0j
\endverbatim

\author Бахурин Сергей www.dsplib.org
***************************************************************************** */









/*! ****************************************************************************
\ingroup FILTER_CONV_GROUP
\fn int conv_fft(double* a, int na, double* b, int nb,
                 fft_t* pfft, double* c) 
\brief Линейная свертка двух вещественных векторов с использованием алгоритмов
быстрого преобразования Фурье

Функция рассчитывает линейную свертку двух векторов \f$ c = a * b\f$ используя
секционную обработку с перекрытием в частотной области. Это позволяет сократить 
вычислительные операции при расчете длинных сверток.



\param[in]  a
Указатель на первый вектор  \f$a\f$. \n 
Размер вектора `[na x 1]`. \n  \n 

\param[in]  na
Размер первого вектора. \n  \n 

\param[in]  b
Указатель на второй вектор \f$b\f$. \n 
Размер вектора `[nb x 1]`. \n  \n 

\param[in]  nb
Размер второго вектора. \n  \n 

\param[in]  pfft
Указатель на структуру `fft_t` алгоритма 
быстрого преобразования Фурье. \n 
Функция изменит состояние полей структуры `fft_t`,
поэтому структура должна быть очищена перед выходом из 
программы для исключения утечек памяти. \n 

\param[in]  nfft
Размер алгоритма БПФ который будет использован для расчета
секционной свертки с перекрытием. \n 
Данный параметр должен быть больше чем минимальное значение
размеров сворачиваемых векторов. \n 
Например если `na=10`, а `nb=4`, то параметр `nfft` должен быть больше 4. \n 
Библиотека поддерживает алгоритмы БПФ составной длины
\f$n = n_0 \times n_1 \times n_2 \times \ldots \times n_p \times m\f$,
где \f$n_i = 2,3,5,7\f$, а \f$m \f$ --- произвольный простой множитель 
не превосходящий 46340 (см. описание функции \ref fft_create).
Однако, максимальное быстродействие достигается при использовании длин равных 
степени двойки.

\param[out] c
Указатель на вектор свертки \f$ c = a * b\f$. \n 
Размер вектора `[na + nb - 1  x  1]`. \n 
Память должна быть выделена. \n  \n 

\return
`RES_OK` если свертка рассчитана успешно. \n 
 В противном случае \ref ERROR_CODE_GROUP "код ошибки".


\note
Данная функция наиболее эффективна при вычислении длинных сверток.

Пример использования функции:

\include conv_fft_test.c

Результат работы:
\verbatim

conv_fft error: 0x00000000
conv error:     0x00000000
c[  0] =     -0.00    d[  0] =      0.00
c[  1] =     -0.00    d[  1] =      0.00
c[  2] =      1.00    d[  2] =      1.00
c[  3] =      4.00    d[  3] =      4.00
c[  4] =     10.00    d[  4] =     10.00
c[  5] =     20.00    d[  5] =     20.00
c[  6] =     35.00    d[  6] =     35.00
c[  7] =     56.00    d[  7] =     56.00
c[  8] =     77.00    d[  8] =     77.00
c[  9] =     98.00    d[  9] =     98.00
c[ 10] =    119.00    d[ 10] =    119.00
c[ 11] =    140.00    d[ 11] =    140.00
c[ 12] =    161.00    d[ 12] =    161.00
c[ 13] =    182.00    d[ 13] =    182.00
c[ 14] =    190.00    d[ 14] =    190.00
c[ 15] =    184.00    d[ 15] =    184.00
c[ 16] =    163.00    d[ 16] =    163.00
c[ 17] =    126.00    d[ 17] =    126.00
c[ 18] =     72.00    d[ 18] =     72.00
\endverbatim

\author
Бахурин Сергей
www.dsplib.org
***************************************************************************** */








/*! ****************************************************************************
\ingroup FILTER_CONV_GROUP
\fn int conv_fft_cmplx(complex_t* a, int na, complex_t* b, int nb,
                       fft_t* pfft, complex_t* c) 
\brief Линейная свертка двух комплексных векторов с использованием алгоритмов
быстрого преобразования Фурье

Функция рассчитывает линейную свертку двух векторов \f$ c = a * b\f$ используя
секционную обработку с перекрытием в частотной области. Это позволяет сократить 
вычислительные операции при расчете длинных сверток.

\param[in]  a
Указатель на первый вектор  \f$a\f$. \n 
Размер вектора `[na x 1]`. \n  \n 

\param[in]  na
Размер первого вектора. \n  \n 

\param[in]  b
Указатель на второй вектор \f$b\f$. \n 
Размер вектора `[nb x 1]`. \n  \n 
  
\param[in]  nb
Размер второго вектора. \n  \n 

\param[in]  pfft
Указатель на структуру `fft_t` алгоритма 
быстрого преобразования Фурье. \n 
Функция изменит состояние полей структуры `fft_t`,
поэтому структура должна быть очищена перед выходом из 
программы для исключения утечек памяти. \n 

\param[in]  nfft
Размер алгоритма БПФ который будет использован для расчета
секционной свертки с перекрытием. \n 
Данный параметр должен быть больше чем минимальное значение
размеров сворачиваемых векторов. \n 
Например если `na=10`, а `nb=4`, то параметр `nfft` должен быть больше 4. \n 
Библиотека поддерживает алгоритмы БПФ составной длины
\f$n = n_0 \times n_1 \times n_2 \times \ldots \times n_p \times m\f$,
где \f$n_i = 2,3,5,7\f$, а \f$m \f$ --- произвольный простой множитель 
не превосходящий 46340 (см. описание функции \ref fft_create).
Однако, максимальное быстродействие достигается при использовании длин равных 
степени двойки.

\param[out] c
Указатель на вектор свертки \f$ c = a * b\f$. \n 
Размер вектора `[na + nb - 1  x  1]`. \n 
Память должна быть выделена. \n  \n 

\return
`RES_OK` если свертка рассчитана успешно. \n 
В противном случае \ref ERROR_CODE_GROUP "код ошибки".


\note
Данная функция наиболее эффективна при вычислении длинных сверток.

Пример использования функции:

\include conv_fft_cmplx_test.c

Результат работы:
\verbatim
c[  0] =     -1.00    -0.00j    d[  0] =     -1.00    +0.00j
c[  1] =     -6.00    +4.00j    d[  1] =     -6.00    +4.00j
c[  2] =    -15.00   +20.00j    d[  2] =    -15.00   +20.00j
c[  3] =    -28.00   +56.00j    d[  3] =    -28.00   +56.00j
c[  4] =    -45.00  +120.00j    d[  4] =    -45.00  +120.00j
c[  5] =    -55.00  +210.00j    d[  5] =    -55.00  +210.00j
c[  6] =    -65.00  +300.00j    d[  6] =    -65.00  +300.00j
c[  7] =    -75.00  +390.00j    d[  7] =    -75.00  +390.00j
c[  8] =    -85.00  +480.00j    d[  8] =    -85.00  +480.00j
c[  9] =    -95.00  +570.00j    d[  9] =    -95.00  +570.00j
c[ 10] =   -105.00  +660.00j    d[ 10] =   -105.00  +660.00j
c[ 11] =   -115.00  +750.00j    d[ 11] =   -115.00  +750.00j
c[ 12] =   -125.00  +840.00j    d[ 12] =   -125.00  +840.00j
c[ 13] =   -135.00  +930.00j    d[ 13] =   -135.00  +930.00j
c[ 14] =   -145.00 +1020.00j    d[ 14] =   -145.00 +1020.00j
c[ 15] =   -124.00 +1080.00j    d[ 15] =   -124.00 +1080.00j
c[ 16] =    -99.00 +1016.00j    d[ 16] =    -99.00 +1016.00j
c[ 17] =    -70.00  +820.00j    d[ 17] =    -70.00  +820.00j
c[ 18] =    -37.00  +484.00j    d[ 18] =    -37.00  +484.00j
\endverbatim

\author
Бахурин Сергей
www.dsplib.org
***************************************************************************** */






/*! ****************************************************************************
\ingroup FILTER_CONV_GROUP
\fn int filter_iir(double* b, double* a, int ord, double* x, int n, double* y)
\brief Фильтрация вещественного сигнала вещественным БИХ-фильтром

Функция рассчитывает выход фильтра заданного выражением
\f[
  H(z) = \frac{\sum_{n = 0}^{N} b_n  z^{-n}}
  {1+{\frac{1}{a_0}}\sum_{m = 1}^{M} a_m  z^{-m}},
\f]
где \f$a_0\f$ не может быть 0, \f$N=M=\f$`ord`.

\param[in]  b
Указатель на вектор коэффициентов числителя 
передаточной функции \f$H(z)\f$ БИХ-фильтра. \n  
Размер вектора `[ord + 1 x 1]`. \n  \n  

\param[in]  a
Указатель на вектор коэффициентов знаменателя
передаточной функции \f$H(z)\f$ БИХ-фильтра. \n  
Размер вектора `[ord + 1 x 1]`. \n  
Этот указатель может быть `NULL`, тогда фильтрация производится 
без использования рекурсивной части 
(вектор коэффициентов `b` задает КИХ-фильтр). \n \n

\param[in]  ord
Порядок фильтра. Количество коэффициентов числителя  и знаменателя 
передаточной функции \f$H(z)\f$ БИХ-фильтра равно `ord + 1`. \n \n

\param[in]  x
Указатель на вектор отсчетов входного сигнала. \n
Размер вектора `[n x 1]`. \n \n

\param[in]  n
Длина входного сигнала. \n \n 

\param[out] y
Указатель на вектор выходных отсчетов фильтра. \n  
Размер вектора `[n x  1]`. \n  
Память должна быть выделена заранее. \n \n

\return
`RES_OK` Если фильтрация произведена успешно. \n 
В противном случае \ref ERROR_CODE_GROUP "код ошибки". \n 

Пример использования функции `filter_iir`:

\include filter_iir_test.c

На входе цифрового фильтра задан сигнал 
\f$s(t) = \sin(2\pi \cdot 0.05 t) + n(t)\f$, где \f$n(t)\f$ белый гауссовский 
шум, с нулевым средним и единичной дисперсией. \n
Фильтр представляет собой эллиптический ФНЧ 6 порядка. 
Входной сигнал фильтруется данным фильтром, и результат сохраняется в файлы:

\verbatim
dat/s.txt  - исходный зашумленный сигнал
dat/sf.txt - сигнал на выходе фильтра.
\endverbatim

По полученным данным производится построение графиков:

\image html filter_iir_test.png

\author Бахурин Сергей www.dsplib.org
***************************************************************************** */






