/*! ****************************************************************************
\ingroup TYPES_GROUP
\typedef complex_t
\brief Описание комплексного типа данных.

Комплексный тип данных в библиотеке DSPL-2.0 определен как 
массив из двух элементов типа `double`.
При этом первый элемент массива определяет реальную часть 
комплексного числа, а второй - мнимую.

Например:

\code{.cpp}
    complex_t z;
    z[0] =  1.0;
    z[1] = -2.0;
\endcode 

Переменная `z = 1-2j`, где `j` - мнимая единица.

Для удобства работы с комплексными числами реализованы 
специальные макросы: \ref RE, \ref IM, \ref ABSSQR
***************************************************************************** */









/*! ****************************************************************************
\ingroup TYPES_GROUP
\def ABSSQR(x)
\brief Макрос возвращает квадрат модуля комплексного числа `x`.

Квадрат модуля комплексного числа \f$ x = a + j  b \f$ равен:

\f[
    |x|^2 = x x^* = a^2 + b^2. 
\f]

Например:
\code{.cpp}
    complex_t z;
    double y;
    RE(z) =  1.0;
    IM(z) = -2.0;
    y = ABSSQR(z);
\endcode 

Переменная `z = 1-2j`, где `j` - мнимая единица, а переменная `y = 5`. 
***************************************************************************** */








/*! ****************************************************************************
\ingroup TYPES_GROUP
\def IM(x)
\brief Макрос определяющий мнимую часть комплексного числа.

Например:
\code{.cpp}
    complex_t z;
    RE(z) =  1.0;
    IM(z) = -2.0;        
\endcode 

Переменная `z = 1-2j`, где `j` - мнимая единица.

Аналогично, макрос можно использовать для получения 
мнимой части комплексного числа:
\code{.cpp}
    complex_t z = {3.0, -4.0};
    double    r;
    r = IM(z);
\endcode    
В данном примере переменная `z = 3-4i`, 
а в переменой `r` будет храниться число -4.
***************************************************************************** */










/*! ****************************************************************************
\ingroup TYPES_GROUP
\def RE(x)
\brief Макрос определяющий реальную часть комплексного числа.

Например:
\code{.cpp}
  complex_t z;
  RE(z) =  1.0;
  IM(z) = -2.0;
\endcode 

Переменная `z = 1-2j`, где `j` - мнимая единица.

Аналогично, макрос можно использовать для получения 
реальной части комплексного числа:

\code{.cpp}
  complex_t z = {3.0, -4.0};
  double    r;
  r = RE(z);
\endcode    
В данном примере переменная `z = 3-4i`, а в переменой `r`
будет храниться число 3.
***************************************************************************** */





/*! ****************************************************************************
\ingroup SPEC_MATH_TRIG_GROUP
\fn int acos_cmplx(complex_t* x, int n, complex_t *y)
\brief  Арккосинус комплексного аргумента `x`

Функция рассчитывает значения арккосинуса комплексного аргумента, 
заданного вектором `x` длины `n`:  \n
\f[
\textrm{Arccos}(x) = \frac{\pi}{2} - \textrm{Arcsin}(x) = 
\frac{\pi}{2} -j \textrm{Ln}\left( j x + \sqrt{1 - x^2} \right)
\f]  


\param[in]  x
Указатель на вектор аргумента комплексного арккосинуса. \n
Размер вектора `[n x 1]`.  \n \n

\param[in]  n
Размер входного и выходного векторов `x` и `y`. \n \n
    

\param[out] y
Указатель на вектор значений комплексного арккосинуса,
соответствующего входному вектору `x`. \n
Размер массива `[n x 1]`.  \n
Память должна быть выделена.  \n \n

\return
`RES_OK` если значение функции рассчитано успешно   .  \n
В противном случае \ref ERROR_CODE_GROUP "код ошибки": \n

\note
Функция может использоваться для расчета арккосинуса аргумента 
большего единицы, когда вещественная функция `acos` не определена.

Например при выполнении следующего кода 
\code{.cpp}
  complex_t x[3] = {{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}};
  complex_t y[3];
  int k;
  
  acos_cmplx(x, 3, y);
  
  for(k = 0; k < 3; k++)
    printf("acos_cmplx(%.1f%+.1fj) = %.3f%+.3fj\n", 
             RE(x[k]), IM(x[k]), RE(y[k]), IM(y[k]));
\endcode 
\n

Результатом работы будет

\verbatim
acos_cmplx(1.0+2.0j) = 1.144-1.529j
acos_cmplx(3.0+4.0j) = 0.937-2.306j
acos_cmplx(5.0+6.0j) = 0.880-2.749j
\endverbatim

\author
Бахурин Сергей
www.dsplib.org 
***************************************************************************** */





/*! ****************************************************************************
\ingroup SPEC_MATH_TRIG_GROUP
\fn int asin_cmplx(complex_t* x, int n, complex_t *y)
\brief  Арксинус комплексного аргумента `x`

Функция рассчитывает значения арксинуса комплексного аргумента, 
заданного вектором `x` длины `n`:  \n
\f[
 \textrm{Arcsin}(x) = j \textrm{Ln}\left( j x + \sqrt{1 - x^2} \right)
\f]  


\param[in]  x
Указатель на вектор аргумента комплексного арксинуса. \n
Размер вектора `[n x 1]`.  \n \n

\param[in]  n
Размер входного и выходного векторов `x` и `y`. \n \n


\param[out] y
Указатель на вектор значений комплексного арксинуса,
соответствующего входному вектору `x`. \n
Размер массива `[n x 1]`.  \n
Память должна быть выделена.  \n \n

\return
`RES_OK` если значение функции рассчитано успешно   .  \n
В противном случае \ref ERROR_CODE_GROUP "код ошибки": \n

\note 
Функция может использоваться для расчета арксинуса аргумента 
большего единицы, когда вещественная функция `acos` не определена.

Например при выполнении следующего кода 
\code{.cpp}
  complex_t x[3] = {{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}};
  complex_t y[3];
  int k;
  
  asin_cmplx(x, 3, y);  
  for(k = 0; k < 3; k++)
    printf("asin_cmplx(%.1f%+.1fj) = %.3f%+.3fj\n", 
            RE(x[k]), IM(x[k]), RE(y[k]), IM(y[k]));
\endcode 
\n

Результатом работы будет

\verbatim
asin_cmplx(1.0+2.0j) = 0.427+1.529j
asin_cmplx(3.0+4.0j) = 0.634+2.306j
asin_cmplx(5.0+6.0j) = 0.691+2.749j
\endverbatim

\author
Бахурин Сергей
www.dsplib.org 
***************************************************************************** */







/*! ****************************************************************************
\ingroup TYPES_GROUP
\fn int cmplx2re(complex_t* x, int n, double* re, double* im)
\brief  Преобразование массива комплексных данных в два массива
        вещественных данных, содержащих реальную и мнимую части 
        исходного массива

Функция заполняет реальные массивы `re` и `im` соответствующими значениями 
реальной и мнимой частей исходного комплексного массива `x`.  \n  


\param[in]  x
Указатель на массив комплексных данных. \n
Размер массива `[n x 1]`.  \n \n

\param[in]  n
Размер массивов входных и выходных данных. \n \n

\param[out] re
Указатель на адрес массива реальной части данных. \n
Размер массива `[n x 1]`.  \n
Память должна быть выделена.  \n \n     

\param[out] im
Указатель на адрес массива мнимой части данных. \n
Размер массива `[n x 1]`.  \n
Память должна быть выделена.  \n \n

\return
`RES_OK` если преобразование произведено успешно.  \n
В противном случае \ref ERROR_CODE_GROUP "код ошибки": \n

Например при выполнении следующего кода 
\code{.cpp}
    complex_t x[3] = {{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}};
    double  re[3], im[3];

    cmplx2re(x, 3, re, im);
\endcode 

Элементам массивов `re`  и `im` будут присвоены значения:

\verbatim
re[0] = 1.0; im[0] = 2.0;
re[1] = 3.0; im[1] = 4.0;
re[2] = 5.0; im[2] = 6.0;
\endverbatim

\author
Бахурин Сергей
www.dsplib.org 
***************************************************************************** */







/*! ****************************************************************************
\ingroup SPEC_MATH_TRIG_GROUP
\fn int cos_cmplx(complex_t* x, int n, complex_t *y)
\brief  Косинус комплексного аргумента `x`

Функция рассчитывает значения косинуса комплексного аргумента, 
заданного вектором `x` длины `n`:  \n
\f[
\textrm{cos}(x) = \frac{\exp(jx) + \exp(-jx)}{2} 
\f]  

\param[in]  x
Указатель на вектор аргумента комплексного косинуса. \n
Размер вектора `[n x 1]`.  \n \n

\param[in]  n
Размер входного и выходного векторов `x` и `y`. \n \n

\param[out] y
Указатель на вектор значений комплексного косинуса,
соответствующего входному вектору `x`. \n
Размер массива `[n x 1]`.  \n
Память должна быть выделена.  \n \n

\return
`RES_OK` если значение функции рассчитано успешно   .  \n
В противном случае \ref ERROR_CODE_GROUP "код ошибки": \n

Например при выполнении следующего кода 
\code{.cpp}
  complex_t x[3] = {{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}};
  complex_t y[3];
  int k;
  
  cos_cmplx(x, 3, y);
  
  for(k = 0; k < 3; k++)
    printf("cos_cmplx(%.1f%+.1fj) = %9.3f%+9.3fj\n", 
            RE(x[k]), IM(x[k]), RE(y[k]), IM(y[k]));
  
 \endcode 
 \n

Результатом работы будет

\verbatim
cos_cmplx(1.0+2.0j) =     2.033   -3.052j
cos_cmplx(3.0+4.0j) =   -27.035   -3.851j
cos_cmplx(5.0+6.0j) =    57.219 +193.428j
\endverbatim

\author
Бахурин Сергей
www.dsplib.org 
***************************************************************************** */




/*! ****************************************************************************
\ingroup SPEC_MATH_COMMON_GROUP
\fn int log_cmplx(complex_t* x, int n, complex_t *y)
\brief  Натуральный логарифм комплексного аргумента `x`

Функция рассчитывает значения натурального логарифма комплексного аргумента, 
заданного вектором `x` длины `n`:  \n
\f[
\textrm{Ln}(x) = j \varphi + \ln(|x|), 
\f]  
где \f$\varphi\f$ --- фаза комплексного числа.

\param[in]  x
Указатель на комплексный вектор аргумента логарифма. \n
Размер вектора `[n x 1]`.  \n \n

\param[in]  n
Размер входного и выходного векторов `x` и `y`. \n \n
    

\param[out] y
Указатель на вектор значений комплексного логарифма,
соответствующего входному вектору `x`. \n
Размер массива `[n x 1]`.  \n
Память должна быть выделена.  \n \n

\return
`RES_OK` если значение функции рассчитано успешно.  \n
В противном случае \ref ERROR_CODE_GROUP "код ошибки": \n

Например при выполнении следующего кода 
\code{.cpp}
  complex_t x[3] = {{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}};
  complex_t y[3];
  int k;

  log_cmplx(x, 3, y);  

  for(k = 0; k < 3; k++)
    printf("log_cmplx(%.1f%+.1fj) = %.3f%+.3fj\n", 
            RE(x[k]), IM(x[k]), RE(y[k]), IM(y[k]));
   
 \endcode 
 \n

Результатом работы будет

\verbatim
log_cmplx(1.0+2.0j) = 0.805+1.107j
log_cmplx(3.0+4.0j) = 1.609+0.927j
log_cmplx(5.0+6.0j) = 2.055+0.876j
\endverbatim

\author
Бахурин Сергей
www.dsplib.org 
***************************************************************************** */









/*! ****************************************************************************
\ingroup TYPES_GROUP
\fn int re2cmplx(double* x, int n, complex_t *y)
\brief Преобразование массива вещественных данных в массив комплексных данных.

Функция заполняет реальные части массива `y` данных соответсвующими значениями 
исходного вещественного массива `x`.  \n  


\param[in]  x
Указатель на массив вещественных данных. \n
Размер массива `[n x 1]`.  \n \n

\param[in]  n
Размер массивов входных и выходных данных. \n \n

\param[out] y
Указатель на адрес массива комплексных данных. \n
Размер массива `[n x 1]`.  \n
Память должна быть выделена.  \n \n


\return
`RES_OK` если преобразование произведено успешно.  \n
В противном случае \ref ERROR_CODE_GROUP "код ошибки": \n



Например при выполнении следующего кода 
\code{.cpp}
    double x[3] = {1.0, 2.0, 3.0};
    complex_t y[3];

    re2cmplx(x, 3, y);
\endcode 

Значениям `y` будут присвоены значения:

\verbatim
    y[0] = 1+0j;
    y[1] = 2+0j;
    y[2] = 3+0j.
\endverbatim

\author
Бахурин Сергей
www.dsplib.org 
***************************************************************************** */





/*! ****************************************************************************
\ingroup SPEC_MATH_TRIG_GROUP
\fn int sin_cmplx(complex_t* x, int n, complex_t *y)
\brief  Синус комплексного аргумента `x`

Функция рассчитывает значения синуса комплексного аргумента, 
заданного вектором `x` длины `n`:  \n
\f[
\textrm{sin}(x) = \frac{\exp(jx) - \exp(-jx)}{2j} 
\f]  


\param[in]  x
Указатель на вектор аргумента комплексного синуса. \n
Размер вектора `[n x 1]`.  \n \n

\param[in]  n
Размер входного и выходного векторов `x` и `y`. \n \n
    

\param[out] y
Указатель на вектор значений комплексного синуса,
соответствующего входному вектору `x`. \n
Размер массива `[n x 1]`.  \n
Память должна быть выделена.  \n \n

\return
`RES_OK` если значение функции рассчитано успешно   .  \n
В противном случае \ref ERROR_CODE_GROUP "код ошибки": \n

Например при выполнении следующего кода 
\code{.cpp}
  complex_t x[3] = {{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}};
  complex_t y[3];
  int k;
  
  sin_cmplx(x, 3, y);
  
  for(k = 0; k < 3; k++)
    printf("sin_cmplx(%.1f%+.1fj) = %9.3f%+9.3fj\n", 
            RE(x[k]), IM(x[k]), RE(y[k]), IM(y[k]));
  
 \endcode 
 \n

Результатом работы будет

\verbatim
sin_cmplx(1.0+2.0j) =     3.166   +1.960j
sin_cmplx(3.0+4.0j) =     3.854  -27.017j
sin_cmplx(5.0+6.0j) =  -193.430  +57.218j
\endverbatim

\author
Бахурин Сергей
www.dsplib.org 
***************************************************************************** */




/*! ****************************************************************************
\ingroup SPEC_MATH_COMMON_GROUP
\fn int sqrt_cmplx(complex_t* x, int n, complex_t *y)
\brief  Квадратный корень из комплексного вектора `x` (поэлементный).

Функция рассчитывает значения квадратного корня комплексного аргумента, 
заданного вектором `x` длины `n`:  \n
\f[
y(k) = \sqrt{x(k)}, \qquad k = 0 \ldots n-1. 
\f]  


\param[in]  x
Указатель на вектор аргумента квадратного корня. \n
Размер вектора `[n x 1]`.  \n \n

\param[in]  n
Размер входного и выходного векторов `x` и `y`. \n \n
    

\param[out] y
Указатель на вектор значений комплексного корня,
соответствующего входному вектору `x`. \n
Размер массива `[n x 1]`.  \n
Память должна быть выделена.  \n \n

\return
`RES_OK` если значение функции рассчитано успешно   .  \n
В противном случае \ref ERROR_CODE_GROUP "код ошибки": \n

Например при выполнении следующего кода 
\code{.cpp}
  complex_t x[3] = {{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}};
  complex_t y[3];
  int k;
  
  sqrt_cmplx(x, 3, y);
  
  for(k = 0; k < 3; k++)
    printf("sqrt_cmplx(%.1f%+.1fj) = %.3f%+.3fj\n", 
            RE(x[k]), IM(x[k]), RE(y[k]), IM(y[k]));
 
\endcode 
\n

Результатом работы будет

\verbatim
sqrt_cmplx(1.0+2.0j) = 1.272+0.786j
sqrt_cmplx(3.0+4.0j) = 2.000+1.000j
sqrt_cmplx(5.0+6.0j) = 2.531+1.185j
\endverbatim

\author
Бахурин Сергей
www.dsplib.org 
***************************************************************************** */
