/*! ****************************************************************************
\ingroup TYPES_GROUP
\typedef complex_t
\brief Описание комплексного типа данных.

Комплексный тип данных в библиотеке DSPL-2.0 определен как 
массив из двух элементов типа `double`.
При этом первый элемент массива определяет реальную часть 
комплексного числа, а второй - мнимую.

Например:

\code{.cpp}
    complex_t z;
    z[0] =  1.0;
    z[1] = -2.0;
\endcode 

Переменная `z = 1-2j`, где `j` - мнимая единица.

Для удобства работы с комплексными числами реализованы 
специальные макросы: \ref RE, \ref IM, \ref ABSSQR
***************************************************************************** */









/*! ****************************************************************************
\ingroup TYPES_GROUP
\def ABSSQR(x)
\brief Макрос возвращает квадрат модуля комплексного числа `x`.

Квадрат модуля комплексного числа \f$ x = a + j  b \f$ равен:

\f[
    |x|^2 = x x^* = a^2 + b^2. 
\f]

Например:
\code{.cpp}
    complex_t z;
    double y;
    RE(z) =  1.0;
    IM(z) = -2.0;
    y = ABSSQR(z);               
\endcode 

Переменная `z = 1-2j`, где `j` - мнимая единица, а переменная `y = 5`. 
***************************************************************************** */








/*! ****************************************************************************
\ingroup TYPES_GROUP
\def IM(x)
\brief Макрос определяющий мнимую часть комплексного числа.

Например:
\code{.cpp}
    complex_t z;
    RE(z) =  1.0;
    IM(z) = -2.0;        
\endcode 

Переменная `z = 1-2j`, где `j` - мнимая единица.

Аналогично, макрос можно использовать для получения 
мнимой части комплексного числа:
\code{.cpp}
    complex_t z = {3.0, -4.0};
    double    r;
    r = IM(z);
\endcode    
В данном примере переменная `z = 3-4i`, 
а в переменой `r` будет храниться число -4.
***************************************************************************** */










/*! ****************************************************************************
\ingroup TYPES_GROUP
\def RE(x)
\brief Макрос определяющий реальную часть комплексного числа.

Например:
\code{.cpp}
  complex_t z;
  RE(z) =  1.0;
  IM(z) = -2.0;
\endcode 

Переменная `z = 1-2j`, где `j` - мнимая единица.

Аналогично, макрос можно использовать для получения 
реальной части комплексного числа:

\code{.cpp}
  complex_t z = {3.0, -4.0};
  double    r;
  r = RE(z);
\endcode    
В данном примере переменная `z = 3-4i`, а в переменой `r`
будет храниться число 3.

***************************************************************************** */





/*! ****************************************************************************
\ingroup SPEC_MATH_TRIG_GROUP
\fn int acos_cmplx(complex_t* x, int n, complex_t *y)
\brief  Арккосинус комплексного аргумента `x`

Функция рассчитывает значения арккосинуса комплексного аргумента, 
заданного вектором `x` длины `n`: <BR>
\f[
\textrm{Arccos}(x) = \frac{\pi}{2} - \textrm{Arcsin}(x) = 
\frac{\pi}{2} -j \textrm{Ln}\left( j x + \sqrt{1 - x^2} \right)
\f]  


\param[in]  x   Указатель на вектор аргумента комплексного арккосинуса.<BR>
                Размер вектора `[n x 1]`. <BR><BR>

\param[in]  n   Размер входного и выходного векторов `x` и `y`.<BR><BR>
    

\param[out] y   Указатель на вектор значений комплексного арккосинуса,
                соответствующего входному вектору `x`.<BR>
                Размер массива `[n x 1]`. <BR>
                Память должна быть выделена. <BR><BR>

\return
`RES_OK` если значение функции рассчитано успешно   . <BR>
В противном случае \ref ERROR_CODE_GROUP "код ошибки":<BR>

\note Функция может использоваться для расчета арккосинуса аргумента 
большего единицы, когда вещественная функция `acos` не определена.

Например при выполнении следующего кода 
\code{.cpp}
  complex_t x[3] = {{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}};
  complex_t y[3];
  int k;
  
  acos_cmplx(x, 3, y);
  
  for(k = 0; k < 3; k++)
    printf("acos_cmplx(%.1f%+.1fj) = %.3f%+.3fj\n", 
             RE(x[k]), IM(x[k]), RE(y[k]), IM(y[k]));
\endcode 
<BR>

Результатом работы будет

\verbatim
acos_cmplx(1.0+2.0j) = 1.144-1.529j
acos_cmplx(3.0+4.0j) = 0.937-2.306j
acos_cmplx(5.0+6.0j) = 0.880-2.749j
\endverbatim

\author
Бахурин Сергей www.dsplib.org 
***************************************************************************** */





/*! ****************************************************************************
\ingroup SPEC_MATH_TRIG_GROUP
\fn int asin_cmplx(complex_t* x, int n, complex_t *y)
\brief  Арксинус комплексного аргумента `x`

Функция рассчитывает значения арксинуса комплексного аргумента, 
заданного вектором `x` длины `n`: <BR>
\f[
 \textrm{Arcsin}(x) = j \textrm{Ln}\left( j x + \sqrt{1 - x^2} \right)
\f]  


\param[in]  x   Указатель на вектор аргумента комплексного арксинуса.<BR>
                Размер вектора `[n x 1]`. <BR><BR>

\param[in]  n   Размер входного и выходного векторов `x` и `y`.<BR><BR>
    

\param[out] y   Указатель на вектор значений комплексного арксинуса,
                соответствующего входному вектору `x`.<BR>
                Размер массива `[n x 1]`. <BR>
                Память должна быть выделена. <BR><BR>

\return
`RES_OK` если значение функции рассчитано успешно   . <BR>
В противном случае \ref ERROR_CODE_GROUP "код ошибки":<BR>

\note Функция может использоваться для расчета арксинуса аргумента 
большего единицы, когда вещественная функция `acos` не определена.

Например при выполнении следующего кода 
\code{.cpp}
  complex_t x[3] = {{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}};
  complex_t y[3];
  int k;
  
  asin_cmplx(x, 3, y);  
  for(k = 0; k < 3; k++)
    printf("asin_cmplx(%.1f%+.1fj) = %.3f%+.3fj\n", 
            RE(x[k]), IM(x[k]), RE(y[k]), IM(y[k]));
\endcode 
<BR>

Результатом работы будет

\verbatim
asin_cmplx(1.0+2.0j) = 0.427+1.529j
asin_cmplx(3.0+4.0j) = 0.634+2.306j
asin_cmplx(5.0+6.0j) = 0.691+2.749j
\endverbatim

\author
Бахурин Сергей www.dsplib.org 
***************************************************************************** */







/*! ****************************************************************************
\ingroup TYPES_GROUP
\fn int cmplx2re(complex_t* x, int n, double* re, double* im)
\brief  Преобразование массива комплексных данных в два массива
        вещественных данных, содержащих реальную и мнимую части 
        исходного массива

Функция заполняет реальные массивы `re` и `im` соответствующими значениями 
реальной и мнимой частей исходного комплексного массива `x`. <BR>  


\param[in]  x   Указатель на массив комплексных данных.<BR>
                Размер массива `[n x 1]`. <BR><BR>

\param[in]  n   Размер массивов входных и выходных данных.<BR><BR>

\param[out] re  Указатель на адрес массива реальной части данных.<BR>
                Размер массива `[n x 1]`. <BR>
                Память должна быть выделена. <BR><BR>     

\param[out] im  Указатель на адрес массива мнимой части данных.<BR>
                Размер массива `[n x 1]`. <BR>
                Память должна быть выделена. <BR><BR>

\return
    `RES_OK`    если преобразование произведено успешно. <BR>
                В противном случае \ref ERROR_CODE_GROUP "код ошибки":<BR>

Например при выполнении следующего кода 
\code{.cpp}
    complex_t x[3] = {{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}};
    double  re[3], im[3];

    cmplx2re(x, 3, re, im);
\endcode 

Элементам массивов `re`  и `im` будут присвоены значения:

\verbatim
re[0] = 1.0; im[0] = 2.0;
re[1] = 3.0; im[1] = 4.0;
re[2] = 5.0; im[2] = 6.0;
\endverbatim

\author Бахурин Сергей. www.dsplib.org 
***************************************************************************** */







/*! ****************************************************************************
\ingroup SPEC_MATH_TRIG_GROUP
\fn int cos_cmplx(complex_t* x, int n, complex_t *y)
\brief  Косинус комплексного аргумента `x`

Функция рассчитывает значения косинуса комплексного аргумента, 
заданного вектором `x` длины `n`: <BR>
\f[
\textrm{cos}(x) = \frac{\exp(jx) + \exp(-jx)}{2} 
\f]  


\param[in]  x   Указатель на вектор аргумента комплексного косинуса.<BR>
                Размер вектора `[n x 1]`. <BR><BR>

\param[in]  n   Размер входного и выходного векторов `x` и `y`.<BR><BR>
    

\param[out] y   Указатель на вектор значений комплексного косинуса,
                соответствующего входному вектору `x`.<BR>
                Размер массива `[n x 1]`. <BR>
                Память должна быть выделена. <BR><BR>

\return
`RES_OK` если значение функции рассчитано успешно   . <BR>
В противном случае \ref ERROR_CODE_GROUP "код ошибки":<BR>

Например при выполнении следующего кода 
\code{.cpp}
  complex_t x[3] = {{1.0, 2.0}, {3.0, 4.0}, {5.0, 6.0}};
  complex_t y[3];
  int k;
  
 
  cos_cmplx(x, 3, y);
  
  for(k = 0; k < 3; k++)
    printf("cos_cmplx(%.1f%+.1fj) = %9.3f%+9.3fj\n", 
            RE(x[k]), IM(x[k]), RE(y[k]), IM(y[k]));
  
 \endcode 
<BR>

Результатом работы будет

\verbatim
cos_cmplx(1.0+2.0j) =     2.033   -3.052j
cos_cmplx(3.0+4.0j) =   -27.035   -3.851j
cos_cmplx(5.0+6.0j) =    57.219 +193.428j
\endverbatim

\author
Бахурин Сергей www.dsplib.org 
***************************************************************************** */







/*! ****************************************************************************
\ingroup TYPES_GROUP
\fn int re2cmplx(double* x, int n, complex_t *y)
\brief Преобразование массива вещественных данных в массив комплексных данных.

Функция заполняет реальные части массива `y` данных соответсвующими значениями 
исходного вещественного массива `x`. <BR>  


\param[in]  x   Указатель на массв вещественных данных.<BR>
                Размер массива `[n x 1]`. <BR><BR>

\param[in]  n   Размер массивов входных и выходных данных.<BR><BR>

\param[out] y   Указатель на адрес массива комплексных данных.<BR>
                Размер массива `[n x 1]`. <BR>
                Память должна быть выделена. <BR><BR>


\return
`RES_OK` если преобразование произведено успешно. <BR>
В противном случае \ref ERROR_CODE_GROUP "код ошибки":<BR>



Например при выполнении следующего кода 
\code{.cpp}
    double x[3] = {1.0, 2.0, 3.0};
    complex_t y[3];

    re2cmplx(x, 3, y);
\endcode 

Значениям `y` будут присвоены значения:

\verbatim	     
    y[0] = 1+0j;
    y[1] = 2+0j;
    y[2] = 3+0j.
\endverbatim

\author
Бахурин Сергей.
www.dsplib.org 
***************************************************************************** */

