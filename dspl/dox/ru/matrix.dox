/*! ****************************************************************************
\ingroup SPEC_MATH_LINALG_GROUP
\struct matrix_t
\brief Структура данных объекта матриц и векторов

Структура описывает вещественные и комплексные матрицы и векторы.

\param  dat  Указатель на область памяти, которая
    хранит матрицу или вектор <BR><BR>

\param  n  Количество строк матрицы. <BR><BR>

\param  m  Количество столбцов матрицы. <BR><BR>

\param  type  Тип матрицы. <BR><BR>


Параметр `dat` преставляет собой указатель типа `void*` ввиду того, что матрица
может содержать как вещественные, так и комплексные значения. Если матрица
вещественная, то перед обращением к элементам матрицы необходимо указатель
`dat` привести к типу `double*`. Аналогично, указатель `dat` необходимо привести
к типу `complex_t*`, если матрица комплексная.

Матрицу заданного размера и типа можно создать функцией \ref matrix_create.
Например
\code

  matrix_t a, b;     // объявляем объекты матриц

  // обнуляем все поля и указатели.
  // Данные шаг рекомендуется ввиду того, что некоторые компиляторы
  // при создании переменной не инициализируют ее нулем.
  memset(&a, 0, sizeof(matrix_t));
  memset(&b, 0, sizeof(matrix_t));

  //создаем вещественную матрицу a размерности [3 x 4]
  err = matrix_create(&a, 3, 4, DAT_DOUBLE);

  // создаем комплексную матрицу b размерности [3 x 2]
  err = matrix_create(&b, 3, 2, DAT_COMPLEX);

  // ....
  // работа с матрицами a и b
  // ....

  //очистить память перед выходом
  matrix_free(&a);
  matrix_free(&b);

\endcode


Двумереные матрицы размером `n` на `m` расположены в памяти в виде линейного
вектора, который организован по строкам. Так некий элемент матрицы \f$a_{ij}\f$
матрицы размерности `n` на `m` будет иметь индекс `j*n+i` (индексация матриц
начинается с нуля). Например:

\code

  matrix_t a;     // объявляем объекты матриц

  // обнуляем все поля и указатели.
  // Данные шаг рекомендуется ввиду того, что некоторые компиляторы
  // при создании переменной не инициализируют ее нулем.
  memset(&a, 0, sizeof(matrix_t));


  // создаем вещественную матрицу a размерности [3 x 4]
  err = matrix_create(&a, 3, 4, DAT_DOUBLE);

  // приводим указатель к double*
  double* x = (double*)(a.dat);

  // присваиваем элемент a[2,3] = 3.0
  x[3 * a.n + 2] = 3.0;

  //очистить память перед выходом
  matrix_free(&a);

\endcode

Если требуется изменить размер матрицы, то можно повторно вызывать функцию
\ref matrix_create. Например:

\code

  matrix_t a;     // объявляем объекты матриц

  // обнуляем все поля и указатели.
  // Данные шаг рекомендуется ввиду того, что некоторые компиляторы
  // при создании переменной не инициализируют ее нулем.
  memset(&a, 0, sizeof(matrix_t));


  // создаем вещественную матрицу a размерности [3 x 4]
  err = matrix_create(&a, 3, 4, DAT_DOUBLE);

  // .....

  // изменяем размер матрицы а на [6 x 7]
  err = matrix_create(&a, 6, 7, DAT_DOUBLE);


  // очистить память перед выходом
  matrix_free(&a);

\endcode


\author
  Бахурин Сергей.
  www.dsplib.org

***************************************************************************** */

