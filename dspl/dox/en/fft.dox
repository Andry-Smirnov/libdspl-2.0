




/*! ****************************************************************************
\ingroup DFT_GROUP
\struct fft_t
\brief Fast Fourier Transform Object Data Structure

The structure stores pointers to twiddle factors and arrays of intermediate 
data of the fast Fourier transform algorithm.

The DSPL library uses an FFT algorithm for composite size.


\param  n
The size of the FFT vector for which memory is allocated 
in the structure arrays.  \n
The parameter `n` must be equal to an integer power of two (radix 2). \n \n


\param  w
Pointer to the vector of twiddle factors. \n
The size of the vector is `[n x 1]`. \n
The memory must be allocated and an array of twiddle factors
must be filled with the \ref fft_create function. \n\n


\param  t0
Pointer to the vector of intermediate results of the FFT algorithm. \n
The size of the vector is `[n x 1]`. \n
Memory must be allocated by \ref fft_create function. \n\n 


\param  t1
Pointer to the vector of intermediate results. \n
The size of the vector is `[n x 1]`. \n
The memory must be allocated with the \ref fft_create function. \n\n
The structure is populated with the \ref fft_create function once
before using the FFT algorithm. \n
A pointer to an object of this structure may be
reused when calling FFT functions. \n
Before exiting the program, dedicated memory for twiddle factors and arrays of 
intermediate data must be cleared by the \ref fft_free function. 
For example:
\code
fft_t pfft = {0};     /* Structure fft_t and clear all fields */
int n = 64;           /* FFT size */

int err;

/* Create and fill FFT structure for 64-points FFT */
err = fft_create(&pfft, n);

/* FFT calculation here            */
/* FFT calculation here one more   */
/* ...  */

/* Clear fft structure */
fft_free(&pfft);
\endcode

\note
It is important to note that if the object `fft_t` was created for the FFT size 
equal to` n`, it can only be used for FFT of size `n`. \n \n
It’s also worth noting that the FFT functions independently control the size, 
and independently allocate the memory of the FFT object, if necessary.
So if you call any function using the `fft_t` structure with filled
data for the FFT length `k` for calculating the FFT of length`n`,
then the structure arrays will be automatically recreated for the length `n`.

\author  Sergey Bakhurin  www.dsplib.org  
***************************************************************************** */










/*! ****************************************************************************
\ingroup DFT_GROUP
\fn int ifft_cmplx(complex_t* x, int n, fft_t* pfft, complex_t* y)
\brief Inverse fast Fourier transform

Function calculates \f$ n \f$-point IFFT of complex data 
\f$ x(m) \f$, \f$ m = 0 \ldots n-1 \f$. \n
\f[
  Y(k) = \frac{1}{N} \sum_{m = 0}^{n-1} x(m)   \exp 
   \left( j   \frac{2\pi}{n}    m    k \right),
\f]
here \f$ k = 0 \ldots n-1 \f$.


\param[in]  x
Pointer to the input vector \f$x(m)\f$, 
\f$ m = 0 \ldots n-1 \f$.  \n
Vector size is `[n x 1]`.  \n \n

\param[in]  n
IFFT size \f$n\f$. \n
IFFT size can be composite: 
\f$n = n_0 \times n_1 \times n_2 \times \ldots \times n_p \times m\f$,
here \f$n_i = 2,3,5,7\f$, а \f$m \f$ -- 
simple number less than 46340
(see \ref fft_create function). \n \n

\param[in]  pfft
Pointer to the `fft_t` object.  \n
This pointer cannot be `NULL`.  \n
Structure \ref fft_t should be previously once
filled with the \ref fft_create function, and the memory should be
cleared before exiting by the \ref fft_free function. \n \n

\param[out] y
Pointer to the IFFT result vector \f$Y(k)\f$, 
\f$ k = 0 \ldots n-1 \f$. \n 
Vector size is `[n x 1]`.  \n
Memory must be allocated. \n \n

\return
`RES_OK` if IFFT is calculated successfully. \n
Else \ref ERROR_CODE_GROUP "code error".


IFFT example:

\include ifft_cmplx_test.c

Result:

\verbatim
| x[ 0] =  1.000   0.000 | y[ 0] = -0.517   0.686 | z[ 0] =   1.000   0.000 |
| x[ 1] =  0.540   0.841 | y[ 1] = -0.943   0.879 | z[ 1] =   0.540   0.841 |
| x[ 2] = -0.416   0.909 | y[ 2] = -2.299   1.492 | z[ 2] =  -0.416   0.909 |
| x[ 3] = -0.990   0.141 | y[ 3] = 16.078  -6.820 | z[ 3] =  -0.990   0.141 |
| x[ 4] = -0.654  -0.757 | y[ 4] =  2.040  -0.470 | z[ 4] =  -0.654  -0.757 |
| x[ 5] =  0.284  -0.959 | y[ 5] =  1.130  -0.059 | z[ 5] =   0.284  -0.959 |
| x[ 6] =  0.960  -0.279 | y[ 6] =  0.786   0.097 | z[ 6] =   0.960  -0.279 |
| x[ 7] =  0.754   0.657 | y[ 7] =  0.596   0.183 | z[ 7] =   0.754   0.657 |
| x[ 8] = -0.146   0.989 | y[ 8] =  0.470   0.240 | z[ 8] =  -0.146   0.989 |
| x[ 9] = -0.911   0.412 | y[ 9] =  0.375   0.283 | z[ 9] =  -0.911   0.412 |
| x[10] = -0.839  -0.544 | y[10] =  0.297   0.318 | z[10] =  -0.839  -0.544 |
| x[11] =  0.004  -1.000 | y[11] =  0.227   0.350 | z[11] =   0.004  -1.000 |
| x[12] =  0.844  -0.537 | y[12] =  0.161   0.380 | z[12] =   0.844  -0.537 |
| x[13] =  0.907   0.420 | y[13] =  0.094   0.410 | z[13] =   0.907   0.420 |
| x[14] =  0.137   0.991 | y[14] =  0.023   0.442 | z[14] =   0.137   0.991 |
| x[15] = -0.760   0.650 | y[15] = -0.059   0.479 | z[15] =  -0.760   0.650 |
| x[16] = -0.958  -0.288 | y[16] = -0.161   0.525 | z[16] =  -0.958  -0.288 |
| x[17] = -0.275  -0.961 | y[17] = -0.300   0.588 | z[17] =  -0.275  -0.961 |
\endverbatim

\author Sergey Bakhurin www.dsplib.org
***************************************************************************** */




/*! ****************************************************************************
\ingroup DFT_GROUP
\fn int fft(double* x, int n, fft_t* pfft, complex_t* y)
\brief Fast Fourier transform for the real vector.

Function calculated \f$ n \f$-points FFT for the real vector 
\f$ x(m) \f$, \f$ m = 0 \ldots n-1 \f$. \n
\f[
  Y(k) = \sum_{m = 0}^{n-1} x(m)   \exp 
  \left( -j   \frac{2\pi}{n}    m    k \right),
\f]
here \f$ k = 0 \ldots n-1 \f$.


\param[in]  x
Pointer to the input real vector \f$x(m)\f$, 
\f$ m = 0 \ldots n-1 \f$.  \n
Vector size is `[n x 1]`.  \n \n

\param[in]  n
FFT size \f$n\f$. \n
FFT size can be composite: 
\f$n = n_0 \times n_1 \times n_2 \times \ldots \times n_p \times m\f$,
here \f$n_i = 2,3,5,7\f$, а \f$m \f$ -- 
simple number less than 46340
(see \ref fft_create function). \n \n

\param[in]  pfft
Pointer to the `fft_t` object.  \n
This pointer cannot be `NULL`.  \n
Structure \ref fft_t should be previously once
filled with the \ref fft_create function, and the memory should be
cleared before exiting by the \ref fft_free function. \n \n

\param[out] y
Pointer to the FFT result complex vector \f$Y(k)\f$, 
\f$ k = 0 \ldots n-1 \f$. \n
Vector size is `[n x 1]`. \n
Memory must be allocated. \n \n

\return
`RES_OK` if FFT is calculated successfully. \n
Else \ref ERROR_CODE_GROUP "code error".


Example:

\include fft_test.c

Result:

\verbatim
y[ 0] =    91.000    0.000
y[ 1] =    -7.000   30.669
y[ 2] =    -7.000   14.536
y[ 3] =    -7.000    8.778
y[ 4] =    -7.000    5.582
y[ 5] =    -7.000    3.371
y[ 6] =    -7.000    1.598
y[ 7] =    -7.000    0.000
y[ 8] =    -7.000   -1.598
y[ 9] =    -7.000   -3.371
y[10] =    -7.000   -5.582
y[11] =    -7.000   -8.778
y[12] =    -7.000  -14.536
y[13] =    -7.000  -30.669
\endverbatim

\author Sergey Bakhurin www.dsplib.org 
***************************************************************************** */






/*! ****************************************************************************
\ingroup DFT_GROUP
\fn int fft_cmplx(complex_t* x, int n, fft_t* pfft, complex_t* y)
\brief Fast Fourier transform for the complex vector.

Function calculated \f$ n \f$-points FFT for the complex vector 
\f$ x(m) \f$, \f$ m = 0 \ldots n-1 \f$. \n
\f[
  Y(k) = \sum_{m = 0}^{n-1} x(m)   \exp 
  \left( -j   \frac{2\pi}{n}    m    k \right),
\f]
here \f$ k = 0 \ldots n-1 \f$.

\param[in]  x
Pointer to the input complex vector \f$x(m)\f$, 
\f$ m = 0 \ldots n-1 \f$.  \n
Vector size is `[n x 1]`.  \n \n

\param[in]  n
FFT size \f$n\f$. \n
FFT size can be composite: 
\f$n = n_0 \times n_1 \times n_2 \times \ldots \times n_p \times m\f$,
here \f$n_i = 2,3,5,7\f$, а \f$m \f$ -- 
simple number less than 46340
(see \ref fft_create function). \n \n

\param[in]  pfft
Pointer to the `fft_t` object.  \n
This pointer cannot be `NULL`.  \n
Structure \ref fft_t should be previously once
filled with the \ref fft_create function, and the memory should be
cleared before exiting by the \ref fft_free function. \n \n

\param[out] y
Pointer to the FFT result complex vector \f$Y(k)\f$, 
\f$ k = 0 \ldots n-1 \f$. \n
Vector size is `[n x 1]`. \n
Memory must be allocated. \n \n

\return
`RES_OK` if FFT is calculated successfully. \n
Else \ref ERROR_CODE_GROUP "code error".


Example:

\include fft_cmplx_test.c

Result:

\verbatim
y[ 0] =    -0.517    0.686
y[ 1] =    -0.943    0.879
y[ 2] =    -2.299    1.492
y[ 3] =    16.078   -6.820
y[ 4] =     2.040   -0.470
y[ 5] =     1.130   -0.059
y[ 6] =     0.786    0.097
y[ 7] =     0.596    0.183
y[ 8] =     0.470    0.240
y[ 9] =     0.375    0.283
y[10] =     0.297    0.318
y[11] =     0.227    0.350
y[12] =     0.161    0.380
y[13] =     0.094    0.410
y[14] =     0.023    0.442
y[15] =    -0.059    0.479
y[16] =    -0.161    0.525
y[17] =    -0.300    0.588
\endverbatim

\author Sergey Bakhurin www.dsplib.org 
***************************************************************************** */




/*! ****************************************************************************
\ingroup DFT_GROUP
\fn int fft_create(fft_t* pfft, int n)
\brief Function creates and fill `fft_t` structure.

The function allocates memory and calculates twiddle factors 
 of the `n`-point FFT for the structure` fft_t`.

\param[in,out]  pfft
Pointer to the `fft_t` object.  \n
Pointer cannot be `NULL`.  \n \n

\param[in]  n
FFT size \f$n\f$. \n
FFT size can be composite 
\f$n = n_0 \times n_1 \times n_2 \ldots \times n_p \times m\f$,
here \f$n_i = 2,3,5,7\f$, and \f$m \f$ -- 
 arbitrary prime factor not exceeding 46340. \n
Thus, the FFT algorithm supports arbitrary integer lengths.
degrees of numbers 2,3,5,7, as well as their various combinations.  \n
For example, with \f$ n = 725760 \f$ the structure will be successfully filled, 
because 
\f$ 725760 = 2 \cdot 3 \cdot 4 \cdot 5 \cdot 6 \cdot 7 \cdot 9 \cdot 16 \f$. \n
If \f$ n = 172804 = 43201 \cdot 4 \f$ then the structure will also be 
successfully filled, because the simple factor in \f$ n \f$ does not 
exceed 46340. \n
For size \f$ n = 13 \cdot 17 \cdot 23 \cdot 13 = 66079 \f$
the function will return an error since 66079 is greater than 46340 and is 
not the result of the product of numbers 2,3,5,7. \n \n

\return
`RES_OK` if FFT structure is created and filled successfully. \n
Else \ref ERROR_CODE_GROUP "code error".

\note
Some compilers do not nullify its contents when creating a structure.
Therefore, it is recommended to reset the structure after its declaration:
\code{.cpp}
fft_t pfft = {0};     /* fill and fields of fft_t as zeros*/
int n = 64;           /* FFT size                         */

int err;

/* Create fft_t object for 64-points FFT */

err = fft_create(&pfft, n);

/* ................................... */

/* Clear fft_t structure         */

fft_free(&pfft);
\endcode

Before exiting the program, the memory allocated in the structure
need to clear by  \ref fft_free function. \n \n

\note
The "magic number" 46340 because \f$\sqrt{2^{31}} = 46340.95\f$. \n

\author Sergey Bakhurin www.dsplib.org 
***************************************************************************** */









/*! ****************************************************************************
\ingroup DFT_GROUP
\fn void fft_free(fft_t *pfft)
\brief Free `fft_t` structure.

The function clears the intermediate data memory
and vectors of FFT twiddle factors of the structure `fft_t`.

\param[in] pfft
Pointer to the `fft_t` object. \n

\author Sergey Bakhurin www.dsplib.org 
***************************************************************************** */








/*! ****************************************************************************
\ingroup DFT_GROUP
\fn int fft_shift(double* x, int n, double* y)
\brief Perform a shift of the vector `x`, for use with the `fft` and `ifft` 
functions, in order 
 <a href="http://en.dsplib.org/content/dft_freq/dft_freq.html">
 to move the frequency 0 to the center
</a> of the vector `y`.

\param[in]  x
Pointer to the input vector (FFT or IFFT result).  \n
Vector size is `[n x 1]`.  \n \n

\param[in]  n
Input and output vector size. \n \n

\param[out] y
Pointer to the output vector with frequency 0 in the center. \n
Vector size is `[n x 1]`.  \n
Memory must be allocated. \n \n


\return
`RES_OK` if function is calculated successfully. \n
Else \ref ERROR_CODE_GROUP "code error".

\author Sergey Bakhurin www.dsplib.org 
***************************************************************************** */
