
/*! ****************************************************************************
\ingroup DFT_GROUP
\fn int dft(double* x, int n, complex_t* y)
\brief Дискретное преобразование Фурье вещественного сигнала.

Функция рассчитывает \f$ n \f$-точечное  дискретное преобразование Фурье 
вещественного сигнала \f$ x(m) \f$, \f$ m = 0 \ldots n-1 \f$. \n
\f[
  Y(k) = \sum_{m = 0}^{n-1} x(m)   
  \exp \left( -j   \frac{2\pi}{n}    m    k \right),
\f]
где \f$ k = 0 \ldots n-1 \f$.

\param[in]  x    Указатель на вектор вещественного 
                 входного сигнала \f$x(m)\f$, 
                 \f$ m = 0 \ldots n-1 \f$.  \n
                 Размер вектора `[n x 1]`.  \n \n

\param[in]  n    Размер ДПФ \f$n\f$ (размер векторов 
                 входного сигнала и результата ДПФ). \n \n

\param[out]  y   Указатель на комплексный вектор 
                 результата ДПФ \f$Y(k)\f$, 
                 \f$ k = 0 \ldots n-1 \f$. 
                 Размер вектора `[n x 1]`.  \n
                 Память должна быть выделена. \n \n


\return
`RES_OK`        если ДПФ рассчитана успешно.  \n
                В противном случае \ref ERROR_CODE_GROUP "код ошибки".

Пример использования функции `dft`:

\include dft_test.c

Результат работы программы:

\verbatim
      y[ 0] =   120.000    0.000
      y[ 1] =    -8.000   40.219
      y[ 2] =    -8.000   19.314
      y[ 3] =    -8.000   11.973
      y[ 4] =    -8.000    8.000
      y[ 5] =    -8.000    5.345
      y[ 6] =    -8.000    3.314
      y[ 7] =    -8.000    1.591
      y[ 8] =    -8.000    0.000
      y[ 9] =    -8.000   -1.591
      y[10] =    -8.000   -3.314
      y[11] =    -8.000   -5.345
      y[12] =    -8.000   -8.000
      y[13] =    -8.000  -11.973
      y[14] =    -8.000  -19.314
      y[15] =    -8.000  -40.219
\endverbatim

\note
Данная функция выполняет расчет ДПФ наивным методом 
и требует \f$ n^2 \f$ комплексных умножений. \n
Для увеличения скорости расчета рекомендуется 
использовать алгоритмы быстрого преобразования Фурье.

\author Бахурин Сергей. www.dsplib.org 
***************************************************************************** */



/*! ****************************************************************************
\ingroup DFT_GROUP
\fn int dft_cmplx(complex_t* x, int n, complex_t* y)
\brief Дискретное преобразование Фурье комплексного сигнала.

Функция рассчитывает \f$ n \f$-точечное  дискретное преобразование Фурье 
комплексного сигнала \f$ x(m) \f$, \f$ m = 0 \ldots n-1 \f$. \n
\f[
  Y(k) = \sum_{m = 0}^{n-1} x(m) 
  \exp \left( -j   \frac{2\pi}{n}   m   k \right),
\f]
где \f$ k = 0 \ldots n-1 \f$.

\param[in]  x   Указатель на вектор комплексного 
                входного сигнала \f$x(m)\f$, 
                \f$ m = 0 \ldots n-1 \f$.  \n
                Размер вектора `[n x 1]`.  \n \n

\param[in]  n   Размер ДПФ \f$n\f$ (размер векторов входного 
                сигнала и результата ДПФ). \n \n

\param[out]  y  Указатель на комплексный вектор 
                результата ДПФ \f$Y(k)\f$, 
                \f$ k = 0 \ldots n-1 \f$. 
                Размер вектора `[n x 1]`.  \n
                Память должна быть выделена. \n \n


\return
`RES_OK`        если ДПФ рассчитана успешно.  \n
                В противном случае \ref ERROR_CODE_GROUP "код ошибки".

Пример использования функции `dft_cmplx`:

\include dft_cmplx_test.c

Результат работы программы:

\verbatim
      y[ 0] =   120.000    0.000
      y[ 1] =    -8.000   40.219
      y[ 2] =    -8.000   19.314
      y[ 3] =    -8.000   11.973
      y[ 4] =    -8.000    8.000
      y[ 5] =    -8.000    5.345
      y[ 6] =    -8.000    3.314
      y[ 7] =    -8.000    1.591
      y[ 8] =    -8.000    0.000
      y[ 9] =    -8.000   -1.591
      y[10] =    -8.000   -3.314
      y[11] =    -8.000   -5.345
      y[12] =    -8.000   -8.000
      y[13] =    -8.000  -11.973
      y[14] =    -8.000  -19.314
      y[15] =    -8.000  -40.219
\endverbatim

\note
Данная функция выполняет расчет ДПФ наивным методом 
и требует \f$ n^2 \f$ комплексных умножений. \n
Для увеличения скорости расчета рекомендуется 
использовать алгоритмы быстрого преобразования Фурье.

\author Бахурин Сергей. www.dsplib.org 
***************************************************************************** */




/*! ****************************************************************************
\ingroup DFT_GROUP
\fn int idft_cmplx(complex_t* x, int n, complex_t* y)
\brief Обратное дискретное преобразование Фурье комплексного спектра.

Функция рассчитывает \f$ n \f$-точечное обратное дискретное преобразование Фурье 
комплексного спектра \f$ x(m) \f$, \f$ m = 0 \ldots n-1 \f$. \n
\f[
  y(k) = \sum_{m = 0}^{n-1} x(m) 
  \exp \left( j   \frac{2\pi}{n}   m   k \right),
\f]
где \f$ k = 0 \ldots n-1 \f$.

\param[in]  x   Указатель на вектор входного комплексного 
                спектра сигнала \f$x(m)\f$, 
                \f$ m = 0 \ldots n-1 \f$.  \n
                Размер вектора `[n x 1]`.  \n \n

\param[in]  n   Размер ОДПФ \f$n\f$ (размер векторов входного 
                спектра и результата ОДПФ). \n \n

\param[out]  y  Указатель на комплексный вектор 
                результата ОДПФ \f$y(k)\f$, 
                \f$ k = 0 \ldots n-1 \f$. 
                Размер вектора `[n x 1]`.  \n
                Память должна быть выделена. \n \n


\return
`RES_OK`        если ОДПФ рассчитана успешно.  \n
                В противном случае \ref ERROR_CODE_GROUP "код ошибки".

Пример использования функции `dft_cmplx`:

\include idft_cmplx_test.c

Результат работы программы:

\verbatim
x[ 0] =     0.000   +0.000j,    z[ 0] =     0.000   -0.000
x[ 1] =     1.000   +0.000j,    z[ 1] =     1.000   -0.000
x[ 2] =     2.000   +0.000j,    z[ 2] =     2.000   -0.000
x[ 3] =     3.000   +0.000j,    z[ 3] =     3.000   -0.000
x[ 4] =     4.000   +0.000j,    z[ 4] =     4.000   -0.000
x[ 5] =     5.000   +0.000j,    z[ 5] =     5.000   -0.000
x[ 6] =     6.000   +0.000j,    z[ 6] =     6.000   -0.000
x[ 7] =     7.000   +0.000j,    z[ 7] =     7.000   -0.000
x[ 8] =     8.000   +0.000j,    z[ 8] =     8.000   -0.000
x[ 9] =     9.000   +0.000j,    z[ 9] =     9.000   -0.000
x[10] =    10.000   +0.000j,    z[10] =    10.000   -0.000
x[11] =    11.000   +0.000j,    z[11] =    11.000   +0.000
x[12] =    12.000   +0.000j,    z[12] =    12.000   +0.000
x[13] =    13.000   +0.000j,    z[13] =    13.000   +0.000
x[14] =    14.000   +0.000j,    z[14] =    14.000   +0.000
x[15] =    15.000   +0.000j,    z[15] =    15.000   -0.000
\endverbatim

\note
Данная функция выполняет расчет ОДПФ наивным методом 
и требует \f$ n^2 \f$ комплексных умножений. \n
Для увеличения скорости расчета рекомендуется 
использовать алгоритмы быстрого преобразования Фурье.

\author Бахурин Сергей. www.dsplib.org 
***************************************************************************** */




